}
.LtyToStr <- function (x) {
if (is.numeric(x)) {
c("blank", "solid", "dashed", "dotted", "dotdash", "longdash",
"twodash")[x + 1L]
} else {
x
}
}
colors <- .style(edge.color, node.color, 'fg')
widths <- .style(edge.width, node.width, 'lwd')
ltys <- .style(.LtyToStr(edge.lty), .LtyToStr(node.lty), 'lty')
edge.color <- colors$h
edge.width <- widths$h
edge.lty <- ltys$h
color.v <- colors$v[-seq_len(Ntip)]
width.v <- widths$v[-seq_len(Ntip)]
lty.v <- ltys$v[-seq_len(Ntip)]
DF <- data.frame(edge.color, edge.width, edge.lty, stringsAsFactors = FALSE)
DF <- DF[, c(is.null(node.color), is.null(node.width), is.null(node.lty)),
drop = FALSE]
for (i in seq_len(Nnode)) {
br <- NodeInEdge1[[i]]
if (length(br) == 2) {
A <- br[1]
B <- br[2]
# We should draw a single line if at all possible, for the
# appearance of dotted / dashed line styles.
if (any(DF[A, ] != DF[B, ])) {
## add a new line:
y0v <- c(y0v, y0v[i])
y1v <- c(y1v, yy[i + Ntip])
x0v <- c(x0v, x0v[i])
## shorten the old line:
y0v[i] <- yy[i + Ntip]
if (is.null(node.color)) {
# Half-lines may have different colours
color.v[i] <- edge.color[B]
color.v <- c(color.v, edge.color[A])
} else {
# Use node colour for both half-lines
color.v <- c(color.v, color.v[i])
}
if (is.null(node.width)) {
width.v[i] <- edge.width[B]
width.v <- c(width.v, edge.width[A])
} else {
width.v <- c(width.v, width.v[i])
}
if (is.null(node.lty)) {
lty.v[i] <- edge.lty[B]
lty.v <- c(lty.v, edge.lty[A])
} else {
lty.v <- c(lty.v, lty.v[i])
}
}
}
}
if (horizontal) {
# draw horizontal lines
segments(x0h, y0h, x1h, y0h,
col = edge.color, lwd = edge.width, lty = edge.lty)
# draw vertical lines
segments(x0v, y0v, x0v, y1v,
col = color.v, lwd = width.v, lty = lty.v)
} else {
# draws vertical lines
segments(y0h, x0h, y0h, x1h,
col = edge.color, lwd = edge.width, lty = edge.lty)
# draws horizontal lines
segments(y0v, x0v, y1v, x0v,
col = color.v, lwd = width.v, lty = lty.v)
}
}
cladogram.plot <- function(edge, xx, yy, edge.color, edge.width, edge.lty)
segments(xx[edge[, 1]], yy[edge[, 1]], xx[edge[, 2]], yy[edge[, 2]],
col = edge.color, lwd = edge.width, lty = edge.lty)
circular.plot <- function(edge, Ntip, Nnode, xx, yy, theta,
r, edge.color, edge.width, edge.lty)
### 'edge' must be in postorder order
{
r0 <- r[edge[, 1]]
r1 <- r[edge[, 2]]
theta0 <- theta[edge[, 2]]
costheta0 <- cos(theta0)
sintheta0 <- sin(theta0)
x0 <- r0 * costheta0
y0 <- r0 * sintheta0
x1 <- r1 * costheta0
y1 <- r1 * sintheta0
segments(x0, y0, x1, y1, col = edge.color, lwd = edge.width, lty = edge.lty)
tmp <- which(diff(edge[, 1]) != 0)
start <- c(1, tmp + 1)
Nedge <- dim(edge)[1]
end <- c(tmp, Nedge)
## function dispatching the features to the arcs
foo <- function(edge.feat, default) {
if (length(edge.feat) == 1) return(as.list(rep(edge.feat, Nnode)))
edge.feat <- rep(edge.feat, length.out = Nedge)
feat.arc <- as.list(rep(default, Nnode))
for (k in 1:Nnode) {
tmp <- edge.feat[start[k]]
if (tmp == edge.feat[end[k]]) { # fix by Francois Michonneau (2015-07-24)
feat.arc[[k]] <- tmp
} else {
if (nodedegree[k] == 2)
feat.arc[[k]] <- rep(c(tmp, edge.feat[end[k]]), each = 50)
}
}
feat.arc
}
nodedegree <- tabulate(edge[, 1L])[-seq_len(Ntip)]
co <- foo(edge.color, par("fg"))
lw <- foo(edge.width, par("lwd"))
ly <- foo(edge.lty, par("lty"))
for (k in 1:Nnode) {
i <- start[k]
j <- end[k]
X <- rep(r[edge[i, 1]], 100)
Y <- seq(theta[edge[i, 2]], theta[edge[j, 2]], length.out = 100)
x <- X * cos(Y); y <- X * sin(Y)
x0 <- x[-100]; y0 <- y[-100]; x1 <- x[-1]; y1 <- y[-1]
segments(x0, y0, x1, y1, col = co[[k]], lwd = lw[[k]], lty = ly[[k]])
}
}
unrooted.xy <- function(Ntip, Nnode, edge, edge.length, nb.sp, rotate.tree)
{
foo <- function(node, ANGLE, AXIS) {
ind <- which(edge[, 1] == node)
sons <- edge[ind, 2]
start <- AXIS - ANGLE/2
for (i in 1:length(sons)) {
h <- edge.length[ind[i]]
angle[sons[i]] <<- alpha <- ANGLE*nb.sp[sons[i]]/nb.sp[node]
axis[sons[i]] <<- beta <- start + alpha/2
start <- start + alpha
xx[sons[i]] <<- h*cos(beta) + xx[node]
yy[sons[i]] <<- h*sin(beta) + yy[node]
}
for (i in sons)
if (i > Ntip) foo(i, angle[i], axis[i])
}
Nedge <- dim(edge)[1]
yy <- xx <- numeric(Ntip + Nnode)
## `angle': the angle allocated to each node wrt their nb of tips
## `axis': the axis of each branch
axis <- angle <- numeric(Ntip + Nnode)
## start with the root...
foo(Ntip + 1L, 2*pi, 0 + rotate.tree)
M <- cbind(xx, yy)
axe <- axis[1:Ntip] # the axis of the terminal branches (for export)
axeGTpi <- axe > pi
## make sure that the returned angles are in [-PI, +PI]:
axe[axeGTpi] <- axe[axeGTpi] - 2*pi
list(M = M, axe = axe)
}
node.depth <- function(phy, method = 1)
{
n <- length(phy$tip.label)
m <- phy$Nnode
N <- dim(phy$edge)[1]
phy <- reorder(phy, order = "postorder")
.C(node_depth, as.integer(n),
as.integer(phy$edge[, 1]), as.integer(phy$edge[, 2]),
as.integer(N), double(n + m), as.integer(method))[[5]]
}
node.depth.edgelength <- function(phy)
{
n <- length(phy$tip.label)
m <- phy$Nnode
N <- dim(phy$edge)[1]
phy <- reorder(phy, order = "postorder")
.C(node_depth_edgelength, as.integer(phy$edge[, 1]),
as.integer(phy$edge[, 2]), as.integer(N),
as.double(phy$edge.length), double(n + m))[[5]]
}
node.height <- function(phy, clado.style = FALSE)
{
n <- length(phy$tip.label)
m <- phy$Nnode
N <- dim(phy$edge)[1]
phy <- reorder(phy)
yy <- numeric(n + m)
e2 <- phy$edge[, 2]
yy[e2[e2 <= n]] <- 1:n
phy <- reorder(phy, order = "postorder")
e1 <- phy$edge[, 1]
e2 <- phy$edge[, 2]
if (clado.style)
.C(node_height_clado, as.integer(n), as.integer(e1),
as.integer(e2), as.integer(N), double(n + m), as.double(yy))[[6]]
else
.C(node_height, as.integer(e1), as.integer(e2), as.integer(N),
as.double(yy))[[4]]
}
plot.multiPhylo <- function(x, layout = 1, ...)
{
layout(matrix(1:layout, ceiling(sqrt(layout)), byrow = TRUE))
if (!devAskNewPage() && names(dev.cur()) %in% deviceIsInteractive()) {
devAskNewPage(TRUE)
on.exit(devAskNewPage(FALSE))
}
for (i in seq_along(x)) plot(x[[i]], ...)
}
trex <- function(phy, title = TRUE, subbg = "lightyellow3",
return.tree = FALSE, ...)
{
lastPP <- get("last_plot.phylo", envir = .PlotPhyloEnv)
devmain <- dev.cur() # where the main tree is plotted
restore <- function() {
dev.set(devmain)
assign("last_plot.phylo", lastPP, envir = .PlotPhyloEnv)
}
on.exit(restore())
NEW <- TRUE
cat("Click close to a node. Right-click to exit.\n")
repeat {
x <- identify.phylo(phy, quiet = TRUE)
if (is.null(x)) return(invisible(NULL)) else {
x <- x$nodes
if (is.null(x)) cat("Try again!\n") else {
if (NEW) {
dev.new()
par(bg = subbg)
devsub <- dev.cur()
NEW <- FALSE
} else dev.set(devsub)
tr <- extract.clade(phy, x)
plot(tr, ...)
if (is.character(title)) title(title)
else if (title) {
tl <-
if (is.null(phy$node.label))
paste("From node #", x, sep = "")
else paste("From", phy$node.label[x - Ntip(phy)])
title(tl)
}
if (return.tree) return(tr)
restore()
}
}
}
}
kronoviz <- function(x, layout = length(x), horiz = TRUE, ...)
{
par(mar = rep(0.5, 4), oma = rep(2, 4))
rts <- sapply(x, function(x) branching.times(x)[1])
maxrts <- max(rts)
lim <- cbind(rts - maxrts, rts)
Ntree <- length(x)
Ntips <- sapply(x, Ntip)
if (horiz) {
nrow <- layout
w <- 1
h <- Ntips
} else {
nrow <- 1
w <- Ntips
h <- 1
}
layout(matrix(1:layout, nrow), widths = w, heights = h)
if (layout < Ntree && !devAskNewPage() && interactive()) {
devAskNewPage(TRUE)
on.exit(devAskNewPage(FALSE))
}
if (horiz) {
for (i in 1:Ntree)
plot(x[[i]], x.lim = lim[i, ], ...)
} else {
for (i in 1:Ntree)
plot(x[[i]], y.lim = lim[i, ], direction = "u", ...)
}
axisPhylo(if (horiz) 1 else 4) # better if the deepest tree is last ;)
}
### TIDY
tidy.xy <- function(edge, Ntip, Nnode, xx, yy)
{
yynew <- yy # will be updated to get the new y coordinates after tidying
## initialrange<-diff(range(yy)) #for computing compression. Remove ?
oedge <- edge[match(seq_len(Ntip + Nnode), edge[, 2]), 1] # ordered edges
segofnodes <- data.frame(x1 = xx[oedge], y1 = yy, x2 = xx, y2 = yy) # segment associated to each node
postordernodes <- edge[,2]
nodes <- c(postordernodes[order(xx[postordernodes], decreasing = TRUE)], Ntip + 1) # ensures equal x values to not lead to erroneuos postoder of nodes
GetContourPairsFromSegments <- function(seg, which) {
if (nrow(seg) > 1) { #solves issue with branch length = 0
allx <- sort(unique(c(seg$x1, seg$x2)))
newx2 <- allx[2:length(allx)]
if (which == "top") {
newy2i <- sapply(newx2, function(cx, se) which(cx > se$x1 & cx <= se$x2)[which.max(se$y1[which(cx > se$x1 & cx <= se$x2)])], se = seg)
}
if (which == "bottom") {
newy2i <- sapply(newx2, function(cx, se) which(cx > se$x1 & cx <= se$x2)[which.min(se$y1[which(cx > se$x1 & cx <= se$x2)])], se = seg)
}
newx1 <- allx[1:(length(allx) - 1)]
newy1i <- newy2i
## we simplify segments by merging thsoe on same horiz  (bout a bout)
where2mergei <- which((newy1i[2:length(newy1i)] - newy2i[1:(length(newy1i) - 1)]) == 0)
if (length(where2mergei) > 0) {
newx1 <- newx1[-(where2mergei + 1)]
newy1i <- newy1i[-(where2mergei + 1)]
newx2 <- newx2[-(where2mergei)]
newy2i <- newy2i[-(where2mergei)]
}
newy1ok <- seg$y1[newy1i]
newy2ok <- newy1ok
newseg <- data.frame(x1 = newx1, y1 = newy1ok, x2 = newx2, y2 = newy2ok)
} else {
newseg <- seg
}
newseg
}
GetMinDistBetweenContours <- function(topcontour, bottomcontour) {
## efficient way to compare top and bottom contour by only looking
## at necessary pairs (see original publiction)
d <- NULL
topi <- 1
boti <- 1
while((topi <= nrow(topcontour)) & (boti <= nrow(bottomcontour))) {
d <- c(d, bottomcontour[boti, ]$y1 - topcontour[topi, ]$y1)
if (bottomcontour[boti, ]$x2 < topcontour[topi, ]$x2) boti <- boti + 1
else topi <- topi + 1
}
min(d)
}
N <- list() # will contain all info for each node.
for (n in nodes) {
N[[n]] <- list()
childs <- edge[edge[, 1] == n, 2]
childs.ord <- childs[order(yy[childs])] # childs ordered by y values
desc <- c(childs, unlist(lapply(N[childs], function(x) x$desc)))
diffiny <- 0
if (n > Ntip) { # we are in a node
oldyofcurrentnode <- yynew[n]
for (nn in 2:length(childs.ord)) {
top <- N[[childs.ord[nn - 1]]]$segtop
bot <- N[[childs.ord[nn]]]$segbottom
mindist <- GetMinDistBetweenContours(top, bot)
if (mindist != 1) { # There is room for tidying or untidy up if branches are tangled
mod <- mindist - 1
N[[childs.ord[nn]]]$segbottom[, c(2, 4)] <- N[[childs.ord[nn]]]$segbottom[, c(2, 4)] - mod
N[[childs.ord[nn]]]$segtop[, c(2, 4)] <- N[[childs.ord[nn]]]$segtop[, c(2, 4)] - mod
yynew[c(childs.ord[nn], N[[childs.ord[nn]]]$desc)] <- yynew[c(childs.ord[nn], N[[childs.ord[nn]]]$desc)] - mod
}
}
newyofcurrentnode <- mean(range(yynew[childs.ord]))
yynew[n] <- newyofcurrentnode
diffiny <- oldyofcurrentnode - newyofcurrentnode
}
descseg <- segofnodes[n, ]
descseg[, c(2, 4)] <- descseg[, c(2, 4)] - diffiny
segtop.pre <- rbind(descseg, do.call(rbind, lapply(N[childs], function(x) x$segtop)))
segtop <- GetContourPairsFromSegments(segtop.pre, "top")
segbottom.pre <- rbind(descseg, do.call(rbind, lapply(N[childs], function(x) x$segbottom)))
segbottom <- GetContourPairsFromSegments(segbottom.pre, "bottom")
N[[n]]$childs <- childs.ord
N[[n]]$desc <- desc
N[[n]]$segtop <- segtop
N[[n]]$segbottom <- segbottom
}
yynew <- yynew - (min(yynew) - 1) ## so that min(y)=1 always
## finalrange <- diff(range(yynew)) #for computing compression. Remove?
## compression <- ((initialrange-finalrange)/initialrange)*100 # Remove?
## print(paste("Compression: ", round(compression,2),"%", sep="")) #Remove?
yynew
}
egofnodes
segofnodes
.C(node_height_clado, as.integer(Ntip),
as.integer(z$edge[, 1]), as.integer(z$edge[, 2]),
as.integer(Nedge), double(Ntip + Nnode), as.double(yy))
## 'z' is the tree in postorder order used in calls to .C
z <- reorder(x, order = "postorder")
z
ans <- .C(node_height_clado, as.integer(Ntip),
as.integer(z$edge[, 1]), as.integer(z$edge[, 2]),
as.integer(Nedge), double(Ntip + Nnode), as.double(yy))
node_height_clado
Ntip
as.integer(z$edge[, 1])
as.integer(z$edge[, 2])
as.integer(Nedge)
double(Ntip + Nnode)
yy
yy <- .nodeHeight(z$edge, Nedge, yy)
z$edge
Nedge
### By contrats to ape (< 2.4), the arguments edge.color, etc., are
### not elongated before being passed to segments(), except if needed
### to be reordered
yy <- numeric(Ntip + Nnode)
Nnode
Ntip
x$edge
Nnode <- x$Nnode
Nnode
Nedge <- dim(x$edge)[1]
## node_height_clado requires the number of descendants
## for each node, so we compute `xx' at the same time
ans <- .C(node_height_clado, as.integer(Ntip),
as.integer(z$edge[, 1]), as.integer(z$edge[, 2]),
as.integer(Nedge), double(Ntip + Nnode), as.double(yy))
### By contrats to ape (< 2.4), the arguments edge.color, etc., are
### not elongated before being passed to segments(), except if needed
### to be reordered
yy <- numeric(Ntip + Nnode)
yy
Ntip + Nnode
TIPS <- x$edge[x$edge[, 2] <= Ntip, 2]
yy[TIPS] <- 1:Ntip
yy
x$edge
TIPS <- x$edge[x$edge[, 2] <= Ntip, 2]
yy <- numeric(Ntip + Nnode)
TIPS <- x$edge[x$edge[, 2] <= Ntip, 2]
yy[TIPS] <- 1:Ntip
## node_height_clado requires the number of descendants
## for each node, so we compute `xx' at the same time
ans <- .C(node_height_clado, as.integer(Ntip),
as.integer(z$edge[, 1]), as.integer(z$edge[, 2]),
as.integer(Nedge), double(Ntip + Nnode), as.double(yy))
xx <- ans[[5]] - 1
yy <- ans[[6]]
xx
yy
ans
!use.edge.length
if (!use.edge.length) {
if (node.pos != 2) xx <- .nodeDepth(Ntip, Nnode, z$edge, Nedge, node.depth) - 1
xx <- max(xx) - xx
} else  {
xx <- .nodeDepthEdgelength(Ntip, Nnode, z$edge, Nedge, z$edge.length)
}
xx <- max(xx) - xx
xx
data <-readRDS('data/anoleData.RDS')
tree <-readRDS('data/anoleTree.RDS')
mode <- setNames(data$SVL,row.names(data))
plot5 <- contMap(tree = tree,
x = mode,
method = 'user', show.tip.label = T,
anc.states = estimatesBI,
plot = FALSE
)
shiny::runApp()
plot5 <- contMap(tree = tree,
x = mode,
method = 'user', show.tip.label = T,
anc.states = estimatesBI,
plot = FALSE
)
pp <- get(x = "last_plot.phylo", envir = .PlotPhyloEnv)
pp
pp <- get(x = "last_plot.contMap", envir = .PlotPhyloEnv)
plot5 <- contMap(tree = tree,
x = mode,
method = 'user', show.tip.label = T,
anc.states = estimatesBI,
plot = FALSE
)
get(x = "last_plot.phylo", envir = .PlotPhyloEnv)
plot5 <- contMap(tree = tree,
x = mode,
method = 'user', show.tip.label = T,
anc.states = estimatesBI,
)
pp <- get(x = "last_plot.phylo", envir = .PlotPhyloEnv)
pp
points(x = pp$xx, y = pp$yy,
pch = 21, col = cols, bg = "white", cex = 1.5)
points(x = pp$xx, y = pp$yy,
pch = 21, bg = "white", cex = 1.5)
nodelabels(bg = "white", cex = 0.6, frame = 'none')
points(x = pp$xx, y = pp$yy,
pch = 21, bg = sapply(cols,make.transparent,0.2), cex = 1.5)
runApp()
pp
cbind('x' = pp$xx, 'y' = pp$yy)
cbind('Node'=length(pp$xx), 'x' = pp$xx, 'y' = pp$yy)
cbind('Node'=1:length(pp$xx), 'x' = pp$xx, 'y' = pp$yy)
runApp()
runApp()
runApp()
pp
runApp()
pp$Nnode
pp$Ntip
1:pp$Ntip
runApp()
length(pp$xx)
pp$Ntip+1:length(pp$xx)
length(pp$xx)
pp$Ntip+1:pp$Nnode
runApp()
c(pp$Ntip+1:pp$Nnode,1:pp$Ntip)
c(1:pp$Ntip,pp$Ntip+1:pp$Nnode)
runApp()
runApp()
runApp()
runApp()
estimatesBI
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
